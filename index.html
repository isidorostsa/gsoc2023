<!DOCTYPE html>
<html>

    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="chrome=1" />
        <title>
            P1144 Relocation Semantics | GSoC @ HPX
            2023
        </title>
        <link rel="icon" href="./favicon.ico" />
        <link rel="stylesheet" href="stylesheets/styles.css" />
        <link rel="stylesheet" href="stylesheets/pygment_trac.css" />
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/vivus/0.4.6/vivus.min.js"></script>
        <meta name="viewport" content="width=device-width" />
        <!--[if lt IE 9]>
            <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="wrapper">
            <header>
                <a href="https://stellar-group.org/libraries/hpx/">
                    <img src="./img/stellar_group_icon.svg" width="300px" />
                </a>
            </header>
            <section>
                <h1>Relocation Semantics in the HPX Library</h1>
                <h3>
                    <strong><a href="https://summerofcode.withgoogle.com/"
                            target="_blank">Google Summer of Code
                            2023</a></strong>
                    @
                    <strong><a href="https://stellar-group.org/libraries/hpx/"
                            target="_blank">
                            HPX by the Ste||ar group</a></strong>
                </h3>

                <p>
                    <span class="nameContainer">
                        <strong>Isidoros Tsaousis-Seiras</strong>
                        <a href="https://www.github.com/isidorostsa"
                            target="_blank">
                            <img src="./img/github.svg" width="15px" />
                        </a>
                    </span>
                    <br />
                    Aristotle's University of Thessaloniki
                    <br />
                    <a
                        href="https://github.com/STEllAR-GROUP/hpx/commits?author=isidorostsa&until=2023-09-12"
                        target="_blank">Commits on GitHub</a>
                </p>

                <h2>Motivation</h2>

                <p>
                    HPX provides highly optimized facilities to ensure maximal
                    resource utilization.
                    However there is still performance to be gained in object
                    movement tasks. Proposal
                    <a href="https://isocpp.org/files/papers/P1144R8.html">P1144</a>
                    introduces the idea
                    of <i>relocation</i>. A facility used to hide the
                    boilerplate of object relocation, and optimize it when 
                    possible. Essentially, when relocating a buffer of objects, 
                    the <code>uninitialized_relocate</code>
                    algorithm will determine if it is valid to reduce multiple
                    move-constructor and destructor calls to a
                    single <code>memcpy()</code>. This improvement impacts key
                    primitives like <code>vector.reserve()</code>, leading to 
                    speedup in higher-level programs.
                    <br />
                </p>
                <p>
                    If <code>T</code> is a <i>trivially relocatable</i> type and
                    the buffer is contiguous, then
                    <code>uninitialized_relocate_n</code> will simply
                    call <code>memcpy</code> once, or <code>n</code> times if
                    the buffer is not contiguous. Otherwise it
                    will <code>move</code>+<code>destroy</code> on each object.
                </p>

                <h2>Approach</h2>

                <p>
                    There are two main steps to implement relocation semantics.
                    First, we need to
                    determine if a type is trivially relocatable. Second, we
                    need to implement the
                    relocation mechanism. There is also a third step, which is
                    specific to HPX,
                    and that is to implement the parallelized version of the
                    procedure.
                </p>

                <h3>1&rpar; Detecting trivial relocatability</h3>

                <p>
                    Most types are agnostic to relocation. For example, an <code>std::vector</code>
                    object <b>is</b>
                    trivially relocatable, because it is just a wrapper around
                    pointer to a buffer.

                </p>
                <div style="text-align: center;">
                    <img src="./img/vector_relocation_no_border.svg" width="85%" />
                </div>
                <br />
                <p>
                    It is perfectly safe to <code>memcpy</code> an <code>std::vector</code>
                    to a new location and
                    <code>std::free</code>
                    the old object. That is because:
                </p>
                <ul style="margin-top: -10px;">
                    <li>No destructor will be called and thus the buffer will
                        stay intact</li>
                    <li>The new vector will take care of deallocating the buffer
                        when it is destroyed</li>
                </ul>
                <p>
                    In contrast, an <code>std::string</code> <b>is not</b>
                    trivially relocatable, since
                    it contains a pointer to the internal buffer that is used
                    for small string optimization (sso).
                </p>

                <div style="text-align: center;">
                    <img src="./img/string_relocation_no_border.svg" width="85%" />
                </div>
                <br />
                <p>
                    The copied object will point to the same buffer as the
                    original, and when the original object is
                    <code>std::free</code>-ed, the copied object will be left
                    with a dangling pointer.
                </p>

                <p>
                    Another example of a <b>non</b>-trivially relocatable type
                    is <code>std::list</code>. It is a circularly
                    linked
                    list, so the last element points to the first.
                </p>
                <div style="text-align: center;">
                    <img src="./img/list_relocation_no_border.svg" width="85%" />
                </div>
                <br />
                <p>
                    If we were to <code>memcpy</code> the list (the first node)
                    to a new location, the last element would
                    still point to the old location, so after <code>free</code>-ing,
                    that pointer would be dangling.
                </p>

                <p>
                    Unfortunately, there is no tell-tale sign that a type is
                    trivially relocatable. But, there are ways to
                    cover many common cases:
                    <ol>
                        <li>types that are <i>trivially copyable</i></li>
                        <li>types that have no methods and are exclusively made
                            up of <i>trivially relocatable</i> sub-members
                        </li>
                    </ol>
                </p>

                <p>
                    We can test for the first case using <code>std::is_trivially_copyable</code>.
                    We can not cover the
                    second case with today's C++. And in any case it would be a
                    very limited solution. For example
                    neither cases cover <code>std::vector</code>, which is
                    trivially relocatable, but not trivially copyable
                    and it has methods.
                </p>

                <p>
                    To cover all cases, <a
                        href="https://isocpp.org/files/papers/P1144R8.html">P1144</a>
                    proposes that
                    the user can declare that a type is trivially relocatable.
                </p>

                <p>
                </p>
                <!-- This is
                equal to <code>std::is_trivially_copyable</code> by default and the user can specialize this trait for
                their types.  and this  
                We achieved this is by introducing a new type trait, <code>hpx::is_trivially_relocatable</code>. The user interface we decided to use:
 -->
                <p>
                    To achieve this, HPX offers the following interface,
                    implemented <a
                        href="https://github.com/STEllAR-GROUP/hpx/pull/6264/files#diff-4bb96e21b64e86fe4bab527449733bf3bf0e50b6bd9d900c6f1ea5c76599b166"
                        target="_blank">here</a>:
                </p>
                <!-- HTML generated using hilite.me -->
                <div
                    style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                    <pre style="margin: 0; line-height: 125%">HPX_DECLARE_TRIVIALLY_RELOCATABLE(custom_type);</pre>
                </div>

                <br />
                Which expands to:
                <br />
                <br />
                <!-- HTML generated using hilite.me -->
                <div
                    style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                    <pre style="margin: 0; line-height: 125%"><span style="font-weight: bold">namespace</span> hpx {
    <span style="font-weight: bold">struct</span> is_trivially_relocatable&lt;custom_type&gt; : std::true_type
    {
    };
}</pre>
                </div>
                <br />

                <p>
                    Essentially the user is specializing <code>hpx::is_trivially_relocatable&lt;T&gt;</code>
                    for their type.
                    For <i>trivially copyable</i> types this is <code>true</code>
                    by default. Otherwise it is
                    <code>false</code>.
                    That way we automatically optimize for all the simple cases,
                    but we also let the user benefit
                    further with their own types.
                </p>

                <p>
                    Using <code>hpx::is_trivially_relocatable&lt;T&gt;</code> our algorithms can test 
                    for trivial relocatability to optimize the relocation.
                </p>

                <h3>2&rpar; Applying relocation</h3>

                <p>
                    Let <code>t_buffer</code> be a buffer of <code>n</code>
                    objects of type <code>T</code>, and
                    <code>t_buffer_new</code> be another buffer large enough to
                    fit <code>m</code> &ge; <code>n</code>
                    objects of type <code>T</code>.
                </p>

                <p>
                    The desired state after the relocation is:
                    <ol>
                        <li><code>t_buffer_new</code> contains the objects
                            originally in <code>t_buffer</code></li>
                        <li><code>t_buffer</code> can be repurposed or freed
                            without further cleanup</li>
                    </ol>
                </p>

                <div style="text-align: center;">
                    <img src="./img/relocation.svg" width="85%"/>
                </div>

                <br />

                <p>
                    The traditional approach is to <code>move</code> each object
                    from <code>t_buffer</code> to
                    <code>t_buffer_new</code> and <code>destroy</code>
                    the moved-from objects in <code>t_buffer</code>.
                </p>

                <div style="text-align: center;">
                    <img src="./img/traditional_relocation.svg" width="55%"/>
                </div>
                
                <br />

                <p>
                    This amounts to <b>n</b> calls to <code>T</code>'s move-constructor and <b>n</b> and 
                    to its destructor. Depending on the type, these operations can be
                    expensive. For example, <samp>clang</samp>'s <code>std::vector</code>
                    will set the <code>data</code> pointer of the moved-from object to <code>nullptr</code>
                    and the <code>size</code> and <code>capacity</code> to <code>0</code>.
                </p>

                <p>
                    But since we know that <code>std::vector</code> is a
                    trivially relocatable type, we can do better.
                </p>

                <div style="text-align: center;">
                    <img src="./img/p1144_relocation.svg" width="55%"/>
                </div>
                <br />
                <p>
                    We can simply bitwise-copy the entire buffer
                    from <code>t_buffer</code> to <code>t_buffer_new</code>.
                    This amounts to a single call to <code>memcpy</code> for
                    <code>n*sizeof(T)</code> bytes.
                </p>

                <p>
                    The interface the user sees is:
                </p>
                <pre><samp>uninitialized_relocate_n(t_buffer, n, t_buffer_new);</samp></pre>
                <p>
                    So the implementation details are hidden from them. Internally, the optimized path will be chosen if all of the following conditions are met:
                    <ol>
                        <li><code>T</code> is trivially relocatable</li>
                        <li><code>T</code> is not volatile (<code>memcpy</code> can not be used on volatile objects)</li>
                        <li>The buffer is contiguous</li>
                    </ol>
                </p>
                <p> As seen
                <a href="https://github.com/STEllAR-GROUP/hpx/pull/6324/files#diff-06d3de7d6faa25401e983a45de9b0053a3544d35fe407544840b85403a5e52c4" target="_blank">here</a>.
                </p>

                <p>
                    Testing this for common types, we see that the optimized path is substantially faster.
                </p>

                <div style="text-align: center;">
                    <img src="./img/speedup_graph.svg" width="85%"/>
                    <figcaption>Testing was done on an <a href="https://ark.intel.com/content/www/us/en/ark/products/92981/intel-xeon-processor-e5-2630-v4-25m-cache-2-20-ghz.html" target="_blank">Intel Xeon E5-2630 v4</a> machine</figcaption>

                </div>

                <br />

                <div
                    style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;">
                    <h4>Important note:</h4>
                    The user must not access or destroy the objects in the <b>original</b> buffer. They are either 
                    already destroyed or destroying them would ruin the state of the objects in the new buffer.
                </div>


                <h3>Case 3: binding an array</h3>
                <p>
                    Binding an array by value works like binding data members by
                    value. First the array is copied, and the identifiers refer
                    to the values of the corresponding elements of the copy.
                </p>
                <pre><samp>int arr[] = {1, 2, 3};

auto [x, y, z] = arr;</samp></pre>

                <p>
                    In the snippet above <code>arr</code> is copied and the
                    identifiers (<code>x</code>, <code>y</code>, <code>z</code>)
                    refer to the elements of the copy. The copy of the array is
                    created by an
                    <code>
                        <a
                            href="https://clang.llvm.org/doxygen/classclang_1_1ArrayInitLoopExpr.html"
                            target="_blank">ArrayInitLoopExpr</a></code>, which
                    is also responsible for creating a copy in an
                    implicit copy/move constructor of a class with an array
                    member and when a lambda captures an array by value. This
                    means that handling the mentioned expraession can provide
                    more information to the analyzer about aggregate types and
                    lambdas.
                </p>

                <p>
                    The idea is to copy the array with as little overhead as
                    possible, so for POD arrays the desired approach is to
                    create a
                    <code><a
                            href="https://clang.llvm.org/docs/analyzer/developer-docs/RegionStore.html#lazy-bindings-lazycompoundval"
                            target="_blank">LazyCompoundVal</a></code>, which
                    basically means that the analyzer associates the
                    new array with a snapshot of the old one, instead of
                    creating a memberwise copy.
                </p>

                <p>
                    While it is the desired approach for POD arrays, it is
                    inaccurate for non-POD ones, because the copy constructor
                    can have side effects. For example take a look at this
                    snippet:
                </p>

                <pre><code>struct S {
    inline static int c = 0;
    int i;
                  
    S() : i(++c) {}
    S(const S &amp;copy) { i = copy.i + 1; }
};

void fn() {
    S arr[2];

    auto [x, y] = arr;
}
</code></pre>

                <p>
                    The copy constructor of <code>S</code> has a side effect,
                    which means it must be evaluated for every element to get an
                    accurate result.
                </p>

                <p>
                    Initially the analyzer wasn't able to model non-POD arrays,
                    so before it could start evaluating structured bindings to
                    such arrays, it needed to be taught how to create and
                    destroy them.
                </p>

                <p>
                    The idea is the same for both creating the array and
                    creating a copy of it. The analyzer should call the
                    constructor/copy constructor for each of the elements in
                    order, and construct each element into the specific target
                    memory region. Later when the lifetime of the array ends,
                    the destructors also need to be invoked, but in a reverse
                    order. The destructor of the last element is invoked first.
                </p>

                <p>
                    Binding by reference works the same way as in case of data
                    members. The array is not copied and the identifiers are
                    references to the elements in the original array.
                </p>

                <h2>Implementation</h2>

                <ul>
                    <li>
                        <a href="https://reviews.llvm.org/D127993"
                            target="_blank">D127993</a>
                        was the first patch applied to the analyzer and it put
                        the initializer of the structured binding into the
                        Control Flow Graph. Because the initializer was missing
                        from the CFG, in some cases it had already been removed
                        from the analyzer's internal state, before it even
                        reached the structured binding declaration. As a result
                        the analyzer had no information about what object were
                        the identifiers being bound to.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D128064"
                            target="_blank">
                            D128064
                        </a>
                        introduced a "Small array binding policy" to the
                        analyzer, which is similar to the already existing
                        "Small struct binding policy". As a result if a
                        <code>LazyCompoundVal</code> of a sufficiently small
                        (smaller than 5 elements) array is about to be created,
                        a by value copy is created instead. This allows the
                        analyzer to produce more accurate warning messages.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D127643"
                            target="_blank">
                            D127643
                        </a>
                        is a simple patch allowing the analyzer to handle
                        structured bindings to data members. It tells the
                        analyzer where to look up a required values.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D126613"
                            target="_blank">D126613</a>
                        implemented <code>ArrayInitLoopExpr</code> and
                        structured bindings to POD arrays.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D128716"
                            target="_blank">
                            D128716
                        </a>
                        fixed a bug when an identifier introduced to a reference
                        type was treated as if it was a non-reference type. An
                        example snippet that helps understanding the bug:
                        <br />
                        <br />
                        <pre><code>struct S { int &amp;x; };

void fn() {
    int i = 1;
    S s{i};

    auto [a] = s;
}</code></pre>
                        Here the type of <code>a</code> is <code>int &</code>,
                        however it was treated as <code>int</code>, which lead
                        to false positives.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D127973"
                            target="_blank">
                            D127973
                        </a>
                        made it possible to evaluate the constructor of each
                        element in a non-POD array of less than or equal to 4
                        elements. The analyzer allows the same statement to be
                        repeated 4 times by default, hence the 4 element limit.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D129496"
                            target="_blank">
                            D129496
                        </a>
                        applied the ideas of the previous patch to
                        <code>ArrayInitLoopExpr</code>, and made it possible to
                        create structured bindings to small non-POD arrays as
                        well as to evaluate implicit copy and move constructors
                        of classes/structs with non-POD array fields properly.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D129967"
                            target="_blank">
                            D129967
                        </a>
                        has been extracted from the previous patch and
                        introduced a new
                        <code>
                            <a
                                href="https://clang.llvm.org/doxygen/classclang_1_1ConstructionContext.html"
                                target="_blank">
                                ConstructionContext</a></code>
                        for lambda captures, and introduced capturing non-POD
                        arrays in lambdas by value.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D128837"
                            target="_blank">
                            D128837
                        </a>
                        introduced structured bindings to tuple-like types. It
                        modified the CFG and the
                        <a
                            href="https://discourse.llvm.org/t/analyzer-an-in-depth-look-at-liveness-analysis-in-the-static-analyzer/56008"
                            target="_blank">Liveness Analysis</a>
                        so that a new variable is created for each identifier,
                        and it's lifetime is properly managed.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131784"
                            target="_blank">
                            D131784
                        </a>
                        fixed an issue introduced by
                        <a href="https://reviews.llvm.org/D129967"
                            target="_blank">
                            D129967 </a>, which lead to a crash on copy elided
                        initialized
                        lambda captures. E.g.:
                        <code>[var = S()](){};</code> compiled with
                        <code>-std=c++17</code> or higher.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131944"
                            target="_blank">
                            D131944
                        </a>
                        removed pattern matching for lambda capture initializers
                        completely as they were hard to maintain and caused
                        crashes.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131840"
                            target="_blank">
                            D131840
                        </a>
                        introduced a solution for handling multidimensional
                        non-POD arrays in <code>ArrayInitLoopExpr</code>, so the
                        analyzer can properly model when such arrays are used in
                        structured bindings, lambda captures and implicit
                        copy/move constructors.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D130737"
                            target="_blank">
                            D130737
                        </a>
                        introduced non-POD array destruction to the analyzer, so
                        now it's possible to properly reason about non-POD
                        arrays when they're small enough. Before this patch the
                        analyzer could reason about non-POD array construction,
                        but still failed to evaluate their destruction.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131501"
                            target="_blank">
                            D131501
                        </a>
                        introduced special handling for 0 length arrays, which
                        are basically no-ops, so no machine code is generated
                        for them. Before this patch they were treated by the
                        analyzer as if they had 1 element, which could lead to
                        false positives by invoking the constructor and
                        destructor once.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131187"
                            target="_blank">
                            D131187
                        </a>
                        added all the temporary data used to evaluate non-POD
                        array construction and destruction to the
                        <a
                            href="https://llvm.org/devmtg/2019-10/slides/Dergachev-DevelopingTheClangStaticAnalyzer.pdf"
                            target="_blank">Exploded Graph</a>
                        to make it easier to track which element is being
                        constructed or destructed at a specific point.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131262"
                            target="_blank">
                            D131262
                        </a>
                        increased the accuracy of the bug reports. With this
                        patch the bug reporter can keep tracking a specific
                        region even if it encounters a trivial copy/move
                        construction. This patch also improved tracking values
                        inside initializer lists a bit.
                    </li>
                </ul>
                <h3>Additional patches</h3>
                <ul>
                    <li>
                        <a href="https://reviews.llvm.org/D132654"
                            target="_blank">
                            D132654
                        </a>
                        fixed a false positive warning in a
                        <a href="https://clang.llvm.org/extra/clang-tidy/"
                            target="_blank">clang-tidy</a>
                        checker that was reported when an array was used as the
                        initializer of a structured binding or was captured in a
                        lambda by value.
                    </li>
                    <br />
                    <li>
                        <a href="https://reviews.llvm.org/D131299"
                            target="_blank">
                            D131299
                        </a>
                        created a new analyzer
                        <a
                            href="https://clang.llvm.org/docs/analyzer/checkers.html#core-uninitialized-newarraysize-c"
                            target="_blank">checker</a>
                        that warns if the expression used to determine the
                        number of elements inside <code>new[]</code> evaluates
                        to a garbage value.
                    </li>
                </ul>

                <h2>Results</h2>
                <p>
                    Structured bindings are a C++17 addition, so testing the
                    changes required projects written in C++17 or above. Finding
                    sufficiently large projects with extensive structured
                    binding usage was quite challenging, since the majority of
                    large open-source C++ projects are written in C++14 or
                    below.
                </p>
                <p>
                    Most of the testing was done on
                    <a href="https://github.com/EQMG/Acid" target="_blank">Acid</a>
                    and
                    <a href="https://github.com/WebKit/WebKit" target="_blank">WebKit</a>
                    and their dependencies, including
                    <a href="https://github.com/bulletphysics/bullet3"
                        target="_blank">Bullet</a>,
                    <a href="https://github.com/KhronosGroup/glslang"
                        target="_blank">Glslang</a>
                    and
                    <a href="https://github.com/glfw/glfw" target="_blank">GLFW</a>.
                    On top that, the changes have also been evaluated on
                    several C++14 or earlier open-source projects, including
                    <a href="https://github.com/qt/qtbase" target="_blank">Qt</a>,
                    <a href="https://github.com/sqlite/sqlite" target="_blank">SQLite</a>
                    and
                    <a href="https://github.com/llvm/llvm-project"
                        target="_blank">LLVM</a>
                    itself.
                </p>

                <p>
                    Both the coverage and the accuracy of the analysis have been
                    improved. On WebKit 81 false positives have been replaced by
                    22 true positives and
                    <a href="https://github.com/llvm/llvm-project/issues/42387"
                        target="_blank">Issue #42387</a>
                    has been resolved too.
                </p>

                <h2>Future work</h2>

                <p>
                    There are several improvements that could increase the
                    accuracy and coverage of the analysis. Most of them are not
                    structured binding specific, but are strongly connected to
                    the implementations used to teach the analyzer about
                    structured bindings.
                </p>

                <ul>
                    <li>
                        Currently the analyzer can only reason about known
                        values inside a <code>LazyCompoundVal</code>. It can't
                        tell the difference between <code>Unknown</code> and
                        <code>Undefined</code> values. This sometimes leads to
                        false negatives, so an uninitialized assignment might
                        not be detected. Modifying the analyzer so that it can
                        decide what such values are could increase the accuracy
                        of the analysis.
                    </li>
                    <br />
                    <li>
                        Detecting whether a constructor/destructor has side
                        effects could also increase the accuracy of the
                        analysis. For example the
                        <a
                            href="https://clang.llvm.org/docs/analyzer/checkers.html#deadcode"
                            target="_blank">Dead Code
                            Checker</a>
                        relies on such information, and because it's not
                        provided with that, it can't detect when a non-POD
                        variable is unused. Also if the analyzer knew if there
                        are no side effects, invoking the constructor for every
                        element in a non-POD array could also be avoided.
                    </li>
                    <br />
                    <li>
                        Analysis of non-POD
                        <a
                            href="https://en.cppreference.com/w/c/language/array#Variable-length_arrays"
                            target="_blank">variable-length arrays</a>.
                        Currently the analyzer only handles arrays if their
                        element count is known at compile time.
                    </li>
                    <br />
                    <li>
                        Creating a new <code>ConstructionContext</code> for
                        lambdas. Currently lambdas are constructed into a
                        temporary memory region from which they are moved to
                        their final region. A
                        <code>ConstructionContext</code> would allow the
                        analyzer to construct the lambdas directly into their
                        final regions, so the temporary construction could be
                        avoided.
                    </li>
                </ul>

                <h2>Special thanks</h2>

                <p>
                    I'd like to thank
                    <a href="https://github.com/haoNoQ" target="_blank">Artem
                        Dergachev</a>,
                    <a href="https://github.com/xazax-hun" target="_blank">Gábor
                        Horváth</a>,
                    <a href="https://github.com/Szelethus" target="_blank">Kristóf
                        Umann</a>
                    and
                    <a href="https://github.com/t-rasmud" target="_blank">Rashmi
                        Mudduluru</a>
                    for mentoring the project, helping with testing the various
                    patches on a couple of open-source projects and answering my
                    questions even during the weekends.
                    <br />
                    <br />
                    I'd also like to thank
                    <a href="https://github.com/usama54321" target="_blank">Usama
                        Hameed</a>,
                    <a href="https://github.com/ziqingluo-90" target="_blank">Ziqing
                        Luo</a>
                    and
                    <a href="https://github.com/malavikasamak" target="_blank">Malavika
                        Samak</a>
                    for being part our weekly discussions, as well as
                    <a href="https://github.com/steakhal" target="_blank">Balázs
                        Benics</a>
                    and
                    <a href="https://github.com/martong" target="_blank">Gábor
                        Márton</a>
                    for code reviews and ideas about how the new features could
                    be improved.
                </p>
            </section>
            <footer>
                <p>
                    <small>Hosted on GitHub Pages &mdash; Theme by
                        <a href="https://github.com/orderedlist" target="_blank">orderedlist</a><br />
                        Article template by <a
                            href="https://isuckatcs.github.io/gsoc2022/"
                            target="_blank">isuckatcs</a><br /><br />
The benchmarks presented here have been produced using the Aristotle University of Thessaloniki (AUTh) High Performance Computing Infrastructure.
</small>
                </p>
            </footer>
        </div>
        <script src="javascripts/scale.fix.js"></script>
    </body>

</html>